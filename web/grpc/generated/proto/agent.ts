// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v6.33.2
// source: proto/agent.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type handleBidiStreamingCall,
  makeGenericClientConstructor,
  type Metadata,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "agent";

export interface AgentMessage {
  server_id: string;
  timestamp: string;
  signature: string;
  sequence: number;
  status_update?: StatusUpdate | undefined;
  work_complete?: WorkComplete | undefined;
  heartbeat?: Heartbeat | undefined;
}

export interface ControlPlaneMessage {
  sequence: number;
  work?: WorkItem | undefined;
  ack?: Acknowledgement | undefined;
  error?: Error | undefined;
  connected?: ConnectionAccepted | undefined;
  caddy_config?: CaddyConfig | undefined;
  dns_config?: DnsConfig | undefined;
}

export interface CaddyConfig {
  routes: CaddyRoute[];
}

export interface CaddyRoute {
  id: string;
  domain: string;
  upstreams: string[];
  internal: boolean;
}

export interface StatusUpdate {
  resources: Resources | undefined;
  public_ip: string;
}

export interface Resources {
  cpu_cores: number;
  memory_total_mb: number;
  disk_total_gb: number;
}

export interface WorkItem {
  id: string;
  type: string;
  payload: Uint8Array;
}

export interface WorkComplete {
  work_id: string;
  status: string;
  logs: string;
}

export interface Heartbeat {
  timestamp: number;
}

export interface Acknowledgement {
  message_id: string;
  success: boolean;
}

export interface Error {
  code: number;
  message: string;
  fatal: boolean;
}

export interface ConnectionAccepted {
  session_id: string;
}

export interface DnsConfig {
  records: DnsRecord[];
}

export interface DnsRecord {
  name: string;
  ips: string[];
}

function createBaseAgentMessage(): AgentMessage {
  return {
    server_id: "",
    timestamp: "",
    signature: "",
    sequence: 0,
    status_update: undefined,
    work_complete: undefined,
    heartbeat: undefined,
  };
}

export const AgentMessage: MessageFns<AgentMessage> = {
  encode(message: AgentMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.server_id !== "") {
      writer.uint32(10).string(message.server_id);
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.sequence !== 0) {
      writer.uint32(32).uint64(message.sequence);
    }
    if (message.status_update !== undefined) {
      StatusUpdate.encode(message.status_update, writer.uint32(82).fork()).join();
    }
    if (message.work_complete !== undefined) {
      WorkComplete.encode(message.work_complete, writer.uint32(90).fork()).join();
    }
    if (message.heartbeat !== undefined) {
      Heartbeat.encode(message.heartbeat, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.server_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sequence = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.status_update = StatusUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.work_complete = WorkComplete.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.heartbeat = Heartbeat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentMessage {
    return {
      server_id: isSet(object.server_id) ? globalThis.String(object.server_id) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      status_update: isSet(object.status_update) ? StatusUpdate.fromJSON(object.status_update) : undefined,
      work_complete: isSet(object.work_complete) ? WorkComplete.fromJSON(object.work_complete) : undefined,
      heartbeat: isSet(object.heartbeat) ? Heartbeat.fromJSON(object.heartbeat) : undefined,
    };
  },

  toJSON(message: AgentMessage): unknown {
    const obj: any = {};
    if (message.server_id !== "") {
      obj.server_id = message.server_id;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.status_update !== undefined) {
      obj.status_update = StatusUpdate.toJSON(message.status_update);
    }
    if (message.work_complete !== undefined) {
      obj.work_complete = WorkComplete.toJSON(message.work_complete);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = Heartbeat.toJSON(message.heartbeat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentMessage>, I>>(base?: I): AgentMessage {
    return AgentMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentMessage>, I>>(object: I): AgentMessage {
    const message = createBaseAgentMessage();
    message.server_id = object.server_id ?? "";
    message.timestamp = object.timestamp ?? "";
    message.signature = object.signature ?? "";
    message.sequence = object.sequence ?? 0;
    message.status_update = (object.status_update !== undefined && object.status_update !== null)
      ? StatusUpdate.fromPartial(object.status_update)
      : undefined;
    message.work_complete = (object.work_complete !== undefined && object.work_complete !== null)
      ? WorkComplete.fromPartial(object.work_complete)
      : undefined;
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? Heartbeat.fromPartial(object.heartbeat)
      : undefined;
    return message;
  },
};

function createBaseControlPlaneMessage(): ControlPlaneMessage {
  return {
    sequence: 0,
    work: undefined,
    ack: undefined,
    error: undefined,
    connected: undefined,
    caddy_config: undefined,
    dns_config: undefined,
  };
}

export const ControlPlaneMessage: MessageFns<ControlPlaneMessage> = {
  encode(message: ControlPlaneMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sequence !== 0) {
      writer.uint32(8).uint64(message.sequence);
    }
    if (message.work !== undefined) {
      WorkItem.encode(message.work, writer.uint32(82).fork()).join();
    }
    if (message.ack !== undefined) {
      Acknowledgement.encode(message.ack, writer.uint32(90).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(98).fork()).join();
    }
    if (message.connected !== undefined) {
      ConnectionAccepted.encode(message.connected, writer.uint32(106).fork()).join();
    }
    if (message.caddy_config !== undefined) {
      CaddyConfig.encode(message.caddy_config, writer.uint32(114).fork()).join();
    }
    if (message.dns_config !== undefined) {
      DnsConfig.encode(message.dns_config, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlPlaneMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlPlaneMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sequence = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.work = WorkItem.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ack = Acknowledgement.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.connected = ConnectionAccepted.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.caddy_config = CaddyConfig.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.dns_config = DnsConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlPlaneMessage {
    return {
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      work: isSet(object.work) ? WorkItem.fromJSON(object.work) : undefined,
      ack: isSet(object.ack) ? Acknowledgement.fromJSON(object.ack) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      connected: isSet(object.connected) ? ConnectionAccepted.fromJSON(object.connected) : undefined,
      caddy_config: isSet(object.caddy_config) ? CaddyConfig.fromJSON(object.caddy_config) : undefined,
      dns_config: isSet(object.dns_config) ? DnsConfig.fromJSON(object.dns_config) : undefined,
    };
  },

  toJSON(message: ControlPlaneMessage): unknown {
    const obj: any = {};
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.work !== undefined) {
      obj.work = WorkItem.toJSON(message.work);
    }
    if (message.ack !== undefined) {
      obj.ack = Acknowledgement.toJSON(message.ack);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.connected !== undefined) {
      obj.connected = ConnectionAccepted.toJSON(message.connected);
    }
    if (message.caddy_config !== undefined) {
      obj.caddy_config = CaddyConfig.toJSON(message.caddy_config);
    }
    if (message.dns_config !== undefined) {
      obj.dns_config = DnsConfig.toJSON(message.dns_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlPlaneMessage>, I>>(base?: I): ControlPlaneMessage {
    return ControlPlaneMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlPlaneMessage>, I>>(object: I): ControlPlaneMessage {
    const message = createBaseControlPlaneMessage();
    message.sequence = object.sequence ?? 0;
    message.work = (object.work !== undefined && object.work !== null) ? WorkItem.fromPartial(object.work) : undefined;
    message.ack = (object.ack !== undefined && object.ack !== null)
      ? Acknowledgement.fromPartial(object.ack)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.connected = (object.connected !== undefined && object.connected !== null)
      ? ConnectionAccepted.fromPartial(object.connected)
      : undefined;
    message.caddy_config = (object.caddy_config !== undefined && object.caddy_config !== null)
      ? CaddyConfig.fromPartial(object.caddy_config)
      : undefined;
    message.dns_config = (object.dns_config !== undefined && object.dns_config !== null)
      ? DnsConfig.fromPartial(object.dns_config)
      : undefined;
    return message;
  },
};

function createBaseCaddyConfig(): CaddyConfig {
  return { routes: [] };
}

export const CaddyConfig: MessageFns<CaddyConfig> = {
  encode(message: CaddyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.routes) {
      CaddyRoute.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaddyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaddyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routes.push(CaddyRoute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaddyConfig {
    return {
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => CaddyRoute.fromJSON(e)) : [],
    };
  },

  toJSON(message: CaddyConfig): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => CaddyRoute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaddyConfig>, I>>(base?: I): CaddyConfig {
    return CaddyConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaddyConfig>, I>>(object: I): CaddyConfig {
    const message = createBaseCaddyConfig();
    message.routes = object.routes?.map((e) => CaddyRoute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCaddyRoute(): CaddyRoute {
  return { id: "", domain: "", upstreams: [], internal: false };
}

export const CaddyRoute: MessageFns<CaddyRoute> = {
  encode(message: CaddyRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.domain !== "") {
      writer.uint32(18).string(message.domain);
    }
    for (const v of message.upstreams) {
      writer.uint32(26).string(v!);
    }
    if (message.internal !== false) {
      writer.uint32(32).bool(message.internal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaddyRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaddyRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upstreams.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.internal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaddyRoute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      upstreams: globalThis.Array.isArray(object?.upstreams)
        ? object.upstreams.map((e: any) => globalThis.String(e))
        : [],
      internal: isSet(object.internal) ? globalThis.Boolean(object.internal) : false,
    };
  },

  toJSON(message: CaddyRoute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.upstreams?.length) {
      obj.upstreams = message.upstreams;
    }
    if (message.internal !== false) {
      obj.internal = message.internal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaddyRoute>, I>>(base?: I): CaddyRoute {
    return CaddyRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaddyRoute>, I>>(object: I): CaddyRoute {
    const message = createBaseCaddyRoute();
    message.id = object.id ?? "";
    message.domain = object.domain ?? "";
    message.upstreams = object.upstreams?.map((e) => e) || [];
    message.internal = object.internal ?? false;
    return message;
  },
};

function createBaseStatusUpdate(): StatusUpdate {
  return { resources: undefined, public_ip: "" };
}

export const StatusUpdate: MessageFns<StatusUpdate> = {
  encode(message: StatusUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resources !== undefined) {
      Resources.encode(message.resources, writer.uint32(10).fork()).join();
    }
    if (message.public_ip !== "") {
      writer.uint32(18).string(message.public_ip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resources = Resources.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.public_ip = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusUpdate {
    return {
      resources: isSet(object.resources) ? Resources.fromJSON(object.resources) : undefined,
      public_ip: isSet(object.public_ip) ? globalThis.String(object.public_ip) : "",
    };
  },

  toJSON(message: StatusUpdate): unknown {
    const obj: any = {};
    if (message.resources !== undefined) {
      obj.resources = Resources.toJSON(message.resources);
    }
    if (message.public_ip !== "") {
      obj.public_ip = message.public_ip;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusUpdate>, I>>(base?: I): StatusUpdate {
    return StatusUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusUpdate>, I>>(object: I): StatusUpdate {
    const message = createBaseStatusUpdate();
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? Resources.fromPartial(object.resources)
      : undefined;
    message.public_ip = object.public_ip ?? "";
    return message;
  },
};

function createBaseResources(): Resources {
  return { cpu_cores: 0, memory_total_mb: 0, disk_total_gb: 0 };
}

export const Resources: MessageFns<Resources> = {
  encode(message: Resources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpu_cores !== 0) {
      writer.uint32(8).int32(message.cpu_cores);
    }
    if (message.memory_total_mb !== 0) {
      writer.uint32(16).int32(message.memory_total_mb);
    }
    if (message.disk_total_gb !== 0) {
      writer.uint32(24).int32(message.disk_total_gb);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cpu_cores = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memory_total_mb = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disk_total_gb = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resources {
    return {
      cpu_cores: isSet(object.cpu_cores) ? globalThis.Number(object.cpu_cores) : 0,
      memory_total_mb: isSet(object.memory_total_mb) ? globalThis.Number(object.memory_total_mb) : 0,
      disk_total_gb: isSet(object.disk_total_gb) ? globalThis.Number(object.disk_total_gb) : 0,
    };
  },

  toJSON(message: Resources): unknown {
    const obj: any = {};
    if (message.cpu_cores !== 0) {
      obj.cpu_cores = Math.round(message.cpu_cores);
    }
    if (message.memory_total_mb !== 0) {
      obj.memory_total_mb = Math.round(message.memory_total_mb);
    }
    if (message.disk_total_gb !== 0) {
      obj.disk_total_gb = Math.round(message.disk_total_gb);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resources>, I>>(base?: I): Resources {
    return Resources.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resources>, I>>(object: I): Resources {
    const message = createBaseResources();
    message.cpu_cores = object.cpu_cores ?? 0;
    message.memory_total_mb = object.memory_total_mb ?? 0;
    message.disk_total_gb = object.disk_total_gb ?? 0;
    return message;
  },
};

function createBaseWorkItem(): WorkItem {
  return { id: "", type: "", payload: new Uint8Array(0) };
}

export const WorkItem: MessageFns<WorkItem> = {
  encode(message: WorkItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(26).bytes(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: WorkItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkItem>, I>>(base?: I): WorkItem {
    return WorkItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkItem>, I>>(object: I): WorkItem {
    const message = createBaseWorkItem();
    message.id = object.id ?? "";
    message.type = object.type ?? "";
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWorkComplete(): WorkComplete {
  return { work_id: "", status: "", logs: "" };
}

export const WorkComplete: MessageFns<WorkComplete> = {
  encode(message: WorkComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.work_id !== "") {
      writer.uint32(10).string(message.work_id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.logs !== "") {
      writer.uint32(26).string(message.logs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.work_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logs = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkComplete {
    return {
      work_id: isSet(object.work_id) ? globalThis.String(object.work_id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      logs: isSet(object.logs) ? globalThis.String(object.logs) : "",
    };
  },

  toJSON(message: WorkComplete): unknown {
    const obj: any = {};
    if (message.work_id !== "") {
      obj.work_id = message.work_id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.logs !== "") {
      obj.logs = message.logs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkComplete>, I>>(base?: I): WorkComplete {
    return WorkComplete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkComplete>, I>>(object: I): WorkComplete {
    const message = createBaseWorkComplete();
    message.work_id = object.work_id ?? "";
    message.status = object.status ?? "";
    message.logs = object.logs ?? "";
    return message;
  },
};

function createBaseHeartbeat(): Heartbeat {
  return { timestamp: 0 };
}

export const Heartbeat: MessageFns<Heartbeat> = {
  encode(message: Heartbeat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Heartbeat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Heartbeat {
    return { timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0 };
  },

  toJSON(message: Heartbeat): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Heartbeat>, I>>(base?: I): Heartbeat {
    return Heartbeat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Heartbeat>, I>>(object: I): Heartbeat {
    const message = createBaseHeartbeat();
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseAcknowledgement(): Acknowledgement {
  return { message_id: "", success: false };
}

export const Acknowledgement: MessageFns<Acknowledgement> = {
  encode(message: Acknowledgement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message_id !== "") {
      writer.uint32(10).string(message.message_id);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Acknowledgement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Acknowledgement {
    return {
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: Acknowledgement): unknown {
    const obj: any = {};
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Acknowledgement>, I>>(base?: I): Acknowledgement {
    return Acknowledgement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Acknowledgement>, I>>(object: I): Acknowledgement {
    const message = createBaseAcknowledgement();
    message.message_id = object.message_id ?? "";
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseError(): Error {
  return { code: 0, message: "", fatal: false };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.fatal !== false) {
      writer.uint32(24).bool(message.fatal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fatal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      fatal: isSet(object.fatal) ? globalThis.Boolean(object.fatal) : false,
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.fatal !== false) {
      obj.fatal = message.fatal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.fatal = object.fatal ?? false;
    return message;
  },
};

function createBaseConnectionAccepted(): ConnectionAccepted {
  return { session_id: "" };
}

export const ConnectionAccepted: MessageFns<ConnectionAccepted> = {
  encode(message: ConnectionAccepted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session_id !== "") {
      writer.uint32(10).string(message.session_id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionAccepted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionAccepted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session_id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionAccepted {
    return { session_id: isSet(object.session_id) ? globalThis.String(object.session_id) : "" };
  },

  toJSON(message: ConnectionAccepted): unknown {
    const obj: any = {};
    if (message.session_id !== "") {
      obj.session_id = message.session_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionAccepted>, I>>(base?: I): ConnectionAccepted {
    return ConnectionAccepted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionAccepted>, I>>(object: I): ConnectionAccepted {
    const message = createBaseConnectionAccepted();
    message.session_id = object.session_id ?? "";
    return message;
  },
};

function createBaseDnsConfig(): DnsConfig {
  return { records: [] };
}

export const DnsConfig: MessageFns<DnsConfig> = {
  encode(message: DnsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.records) {
      DnsRecord.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.records.push(DnsRecord.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsConfig {
    return {
      records: globalThis.Array.isArray(object?.records) ? object.records.map((e: any) => DnsRecord.fromJSON(e)) : [],
    };
  },

  toJSON(message: DnsConfig): unknown {
    const obj: any = {};
    if (message.records?.length) {
      obj.records = message.records.map((e) => DnsRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsConfig>, I>>(base?: I): DnsConfig {
    return DnsConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsConfig>, I>>(object: I): DnsConfig {
    const message = createBaseDnsConfig();
    message.records = object.records?.map((e) => DnsRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDnsRecord(): DnsRecord {
  return { name: "", ips: [] };
}

export const DnsRecord: MessageFns<DnsRecord> = {
  encode(message: DnsRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.ips) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ips.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsRecord {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ips: globalThis.Array.isArray(object?.ips) ? object.ips.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DnsRecord): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ips?.length) {
      obj.ips = message.ips;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsRecord>, I>>(base?: I): DnsRecord {
    return DnsRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsRecord>, I>>(object: I): DnsRecord {
    const message = createBaseDnsRecord();
    message.name = object.name ?? "";
    message.ips = object.ips?.map((e) => e) || [];
    return message;
  },
};

export type AgentServiceService = typeof AgentServiceService;
export const AgentServiceService = {
  connect: {
    path: "/agent.AgentService/Connect",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: AgentMessage): Buffer => Buffer.from(AgentMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer): AgentMessage => AgentMessage.decode(value),
    responseSerialize: (value: ControlPlaneMessage): Buffer => Buffer.from(ControlPlaneMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer): ControlPlaneMessage => ControlPlaneMessage.decode(value),
  },
} as const;

export interface AgentServiceServer extends UntypedServiceImplementation {
  connect: handleBidiStreamingCall<AgentMessage, ControlPlaneMessage>;
}

export interface AgentServiceClient extends Client {
  connect(): ClientDuplexStream<AgentMessage, ControlPlaneMessage>;
  connect(options: Partial<CallOptions>): ClientDuplexStream<AgentMessage, ControlPlaneMessage>;
  connect(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<AgentMessage, ControlPlaneMessage>;
}

export const AgentServiceClient = makeGenericClientConstructor(
  AgentServiceService,
  "agent.AgentService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AgentServiceClient;
  service: typeof AgentServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
